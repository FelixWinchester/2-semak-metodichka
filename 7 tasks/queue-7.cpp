#include <iostream>
#include <fstream>
using namespace std;

// Создаем класс Queue
class Queue {
    // Определяем приватные переменные класса
    private:
        int* arr; // Указатель на массив элементов очереди
        int front; // Индекс первого элемента в очереди
        int rear; // Индекс последнего элемента в очереди
        int capacity; // Максимальный размер очереди
    // Определяем публичные методы класса
    public:
        // Конструктор класса, принимающий максимальный размер очереди
        Queue(int size) {
            arr = new int[size]; // Выделяем память под массив элементов очереди
            capacity = size; // Задаем максимальный размер очереди
            front = 0; // Индекс первого элемента в очереди равен 0
            rear = -1; // Индекс последнего элемента в очереди равен -1
        }

        // Деструктор класса
        ~Queue() {
            delete[] arr; // Освобождаем память, выделенную под массив элементов очереди
        }

        // Метод добавления элемента в конец очереди
        void enqueue(int num) {
            // Проверяем, не является ли очередь полной
            if (isFull()) {
                cout << "Queue is full\n";
            }
            else {
                rear++; // Увеличиваем индекс последнего элемента в очереди
                arr[rear] = num; // Записываем новый элемент в конец очереди
            }
        }

        // Метод удаления элемента из начала очереди
        int dequeue() {
            // Проверяем, не является ли очередь пустой
            if (isEmpty()) {
                cout << "Queue is empty\n";
                return -1; // Возвращаем -1, чтобы указать на ошибку
            }
            else {
                int num = arr[front]; // Сохраняем значение первого элемента в очереди
                front++; // Увеличиваем индекс первого элемента в очереди
                return num; // Возвращаем сохраненное значение
            }
        }

        // Метод проверки, является ли очередь пустой
        bool isEmpty() {
            return (front > rear); // Возвращаем true, если индекс первого элемента больше индекса последнего элемента
        }

        // Метод проверки, является ли очередь полной
        bool isFull() {
            return (rear == capacity - 1); // Возвращаем true, если индекс последнего элемента равен максимальному размеру очереди минус 1
        }

        // Метод удаления дубликатов из очереди
        void removeDuplicates() {
            Queue temp(capacity); // Создаем временную очередь с максимальным размером, равным максимальному размеру исходной очереди
            int prev = dequeue(); // Извлекаем первый элемент из исходной очереди и сохраняем его в переменной prev
            temp.enqueue(prev); // Добавляем сохраненный элемент в конец временной очереди

            // Пока исходная очередь не пуста
            while (!isEmpty()) {
                int curr = dequeue(); // Извлекаем следующий элемент из исходной очереди и сохраняем его в переменной curr
                if (curr != prev) { // Если текущий элемент не равен предыдущему
                    temp.enqueue(curr); // Добавляем текущий элемент в конец временной очереди
                }
                prev = curr; // Сохраняем текущий элемент в переменной prev
            }

            // Пока временная очередь не пуста
            while (!temp.isEmpty()) {
                enqueue(temp.dequeue()); // Извлекаем элемент из начала временной очереди и добавляем его в конец исходной очереди
            }
        }

        // Метод вывода элементов очереди на экран
        void print() {
            for (int i = front; i <= rear; i++) { // Проходим по всем элементам очереди от первого до последнего
                cout << arr[i] << " "; // Выводим значение текущего элемента на экран
            }
            cout << endl; // Переходим на новую строку
        }
};

// Главная функция программы
int main() {
    ifstream fin("input.txt"); // Открываем файл input.txt для чтения
    ofstream fout("output.txt"); // Открываем файл output.txt для записи

    int size, num;
    fin >> size; // Считываем максимальный размер очереди из файла input.txt

    Queue q(size); // Создаем очередь с максимальным размером, равным считанному значению

    // Читаем элементы из файла input.txt и добавляем их в конец очереди
    for (int i = 0; i < size; i++) {
        fin >> num;
        q.enqueue(num);
    }

    q.removeDuplicates(); // Удаляем дубликаты из очереди

    q.print(); // Выводим элементы очереди на экран

    fin.close(); // Закрываем файл input.txt
    fout.close(); // Закрываем файл output.txt

    return 0; 
}
