// A) Вектор
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int Kol_vo(int n) {
    vector<int> digits;
    while (n > 0) {
        digits.push_back(n % 10); // Добавление цифры в конец вектора
        n /= 10; // Удаление последней цифры из числа
    }
    sort(digits.begin(), digits.end()); // Сортировка цифр в порядке возрастания
    int count = 1;
    for (int i = 1; i < digits.size(); ++i) { // Подсчет количества различных цр
        if (digits[i] != digits[i-1]) {
            count++;
        }
    }
    return count;
}

int main() {
    vector<int> v = {1, 2, 3, 4, 5}; // Создание вектора и инициализация его элементами
    int n = v.size(); // Получение размера вектора
    v[1] = Kol_vo(v[1]); // Замена второго элемента на количество различных цифр в его записи
    v[n-2] = Kol_vo(v[n-2]); // Замена предпоследнего элемента на количество различных цифр в его записи
    for (int i = 0; i < n; ++i) { // Вывод элементов вектора на экран
        cout << v[i] << " ";
    }
    return 0;
}

/*
Временная сложность: O(nlogn), где n - размер вектора. Функция Kol_vo имеет временную сложность O(logn), 
так как разбивает число на цифры, а затем сортирует их. Сортировка выполняется за O(nlogn) времени. 
Вставка элементов в вектор и вывод на экран выполняются за O(n) времени.
Выбор контейнера: вектор выбран из-за простоты доступа к элементам по индексу и возможности изменения размера.
*/

// B) Список
/*
#include <iostream>
#include <list>
#include <algorithm>
using namespace std;

// Функция для перестановки цифр числа в обратном порядке
int reverseDigits(int n) {
    int result = 0; // Начальное значение результата равно 0
    while (n > 0) {
        result = result * 10 + n % 10; // Добавление последней цифры числа в конец результата
        n /= 10; // Удаление последней цифры из числа
    }
    return result; // Возвращаем число, полученное из исходного перестановкой цифр в обратном порядке
}

int main() {
    list<int> l = {1, 2, 3, 4, 5}; // Создание списка и инициализация его элементами
    l.insert(++l.begin(), reverseDigits(*l.begin())); // Вставка элемента, полученного из первого элемента списка перестановкой цифр в обратном порядке, после первого элемента
    l.insert(--l.end(), reverseDigits(*--l.end())); // Вставка элемента, получен из последнего элемента списка перестановкой цифр в обратном порядке, перед последним элементом
    for (auto it = l.begin(); it != l.end(); ++it) { // Вывод элементов списка на экран
        cout << *it << " ";
    }
    return 0;
}

*/
/*
Временная сложность: O(n), где n - размер списка. Функция Obratka имеет временную сложность O(log n), 
так как разбивает число на цифры. Вставка элементов в список и вывод на экран выполняются за O(n) времени.
Выбор контейнера: список выб из-за возможности быстрой вставки элементов в середину списка и удаления элементов из него.
*/
